import { ElementStyleState } from "./ElementStyleState"
import { validateConfig } from "../utils/validation"
import { MissingFontSetError } from "../utils/errors"
import { MissingColorThemeError } from "../utils/errors"
import { calculateAverageStepRelativeStep, normalizeElementsToPixels } from "../utils/unitConversion"
import { normalizeStep, detectUnit, detectDominantUnit, detectUnitsFromElements } from '../utils/unitDetection'

export class TextEnhancerModel {
  #config
  #elementStates = []
  #currentFontIndex = 0

  constructor(config) {
    validateConfig(config)
    this.#config = this.#normalizeConfig(config)
    this.#updateElementStates()

    const units = detectUnitsFromElements(this.#elementStates)
    if (units.size > 1) {
      normalizeElementsToPixels(this.#elementStates)
    }

    const rawStep = normalizeStep(this.#config.step)
    const stepUnit = detectUnit(rawStep)
    const dominantUnit = detectDominantUnit(this.#elementStates)

    let convertedStep = parseFloat(rawStep)

    if (dominantUnit === 'noDominantUnit' || stepUnit !== dominantUnit && stepUnit === '_no_unit_') {
      const originalSizes = new Map()
      this.#elementStates.forEach(state => {
        originalSizes.set(state.element, getComputedStyle(state.element).fontSize)
      })

      const relativeStep = calculateAverageStepRelativeStep(
        this.#elementStates.map(state => state.element),
        convertedStep,
        originalSizes
      )

      if (relativeStep !== null) {
        convertedStep = parseFloat(relativeStep.toFixed(2))
      }
    }

    this.#config.step = convertedStep
  }

  #normalizeConfig(config) {
    return {
      selectors: config.selectors || ['p'],
      step: config.step || 2,
      minSize: config.minSize || 6,
      maxSize: config.maxSize || 40,
      fontSets: {
        serif: ['Georgia', 'Times New Roman', 'serif'],
        sans: ['Arial', 'Helvetica', 'sans-serif'],
        // dyslexia: ['OpenDyslexic'] // Example https://opendyslexic.org/
      },
      fontCycle: ['originalFont', 'serif', 'sans'], //, 'dyslexia'],
      colorThemes: {
        light: { textColor: '#000000ff', backgroundColor: '#ffffffff' },
        dark: { textColor: '#b3b3b3ff', backgroundColor: '#222222ff' },
        highContrast: { textColor: '#000000ff', backgroundColor: '#fffb00ff' }
      },
      
      root: config.root || document,
    }
  }

  // Store the original styles of all target elements such as:
  // font size, font family, color, and background color.
  #updateElementStates() {
    const { selectors, root } = this.#config
    const elements = selectors.flatMap(selector =>
      Array.from(root.querySelectorAll(selector))
    )
    this.#elementStates = elements.map(element => new ElementStyleState(element))
  }

  updateTarget(newSelectors) {
    const { root } = this.#config
    this.#config.selectors = newSelectors
    const elements = newSelectors.flatMap(selector =>
      Array.from(root.querySelectorAll(selector))
    )
    this.#elementStates = elements.map(element => new ElementStyleState(element))
  }

  get elementStates() {
    return this.#elementStates
  }

  increaseTextSize() {
    const step = this.#config.step
    const maxSize = this.#config.maxSize

    this.#elementStates.forEach(state => {
      const currentSize = parseFloat(getComputedStyle(state.element).fontSize)
      const newSize = Math.min(currentSize + step, maxSize)

      state.applyFontSize(newSize)
    })
  }
  decreaseTextSize() {
    const step = this.#config.step
    const minSize = this.#config.minSize

    this.#elementStates.forEach(state => {
      const currentSize = parseFloat(getComputedStyle(state.element).fontSize)
      const newSize = Math.max(currentSize - step, minSize)

      state.applyFontSize(newSize)
    })
  }

  setTextToMax() {
    const maxSize = this.#config.maxSize

    this.#elementStates.forEach(state => {
      state.applyFontSize(maxSize)
    })
  }

  setTextToMin() {
    const minSize = this.#config.minSize

    this.#elementStates.forEach(state => {
      state.applyFontSize(minSize)
    })
  }

  restoreTextSize() {
    this.#elementStates.forEach(state => {
      state.restoreFontSize()
    })
  }

  // Font manipulation methods:
  cycleFontSet() {
    const cycle = this.#config.fontCycle
    this.#currentFontIndex = (this.#currentFontIndex + 1) % cycle.length
    const setName = cycle[this.#currentFontIndex]

    if (setName === 'originalFont') {
      this.restoreFontFamily()
    }

    const fontStack = this.#config.fontSets[setName]
    if (Array.isArray(fontStack)) {
      this.#elementStates.forEach(state =>
        state.applyFontFamily(fontStack.join(', '))
      )
    } else {
      throw new MissingFontSetError(setName)
    }
  }

  restoreFontFamily() {
    this.#elementStates.forEach(state => {
      state.restoreFontFamily()
    })
  }

  // Text and background color manipulation methods:
  changeTextColor(color) {
    this.#elementStates.forEach(state => {
      state.applyColor(color)
    })
  }

  changeBackgroundColor(color) {
    this.#elementStates.forEach(state => {
      state.applyBackgroundColor(color)
    })
  }

  applyColorTheme(themeName) {
    const theme = this.#config.colorThemes?.[themeName]

    if (!theme) {
      throw new MissingColorThemeError(themeName)
    }

    this.#elementStates.forEach(state => {
      state.applyColor(theme.textColor)
      state.applyBackgroundColor(theme.backgroundColor)
    })
  }

  restoreColors() {
    this.#elementStates.forEach(state => {
      state.restoreColor()
      state.restoreBackgroundColor()
    })
  }

  getCurrentFontSet() {
    return this.#config.fontCycle[this.#currentFontIndex]
  }

  getConfig() {
    return { ...this.#config }
  }
}
